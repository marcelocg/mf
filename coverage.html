
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">mf/cmd/add.go (0.0%)</option>
				
				<option value="file1">mf/cmd/get.go (0.0%)</option>
				
				<option value="file2">mf/cmd/list.go (0.0%)</option>
				
				<option value="file3">mf/cmd/root.go (0.0%)</option>
				
				<option value="file4">mf/internal/secure/encrypted.go (69.1%)</option>
				
				<option value="file5">mf/internal/secure/keychain.go (0.0%)</option>
				
				<option value="file6">mf/internal/secure/machine.go (92.3%)</option>
				
				<option value="file7">mf/internal/secure/manager.go (0.0%)</option>
				
				<option value="file8">mf/internal/storage/secure_storage.go (87.5%)</option>
				
				<option value="file9">mf/internal/storage/storage.go (79.5%)</option>
				
				<option value="file10">mf/internal/totp/totp.go (100.0%)</option>
				
				<option value="file11">mf/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"

        "mf/internal/storage"
        "mf/internal/totp"
        "mf/internal/types"
)

var addCmd = &amp;cobra.Command{
        Use:   "add [ACCOUNT_NAME] [SECRET]",
        Short: "Adiciona uma nova conta para geração de tokens TOTP",
        Long:  `Adiciona uma nova conta com o nome especificado e o secret fornecido para geração de tokens TOTP.`,
        Args:  cobra.ExactArgs(2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                accountName := args[0]
                secret := args[1]

                if err := totp.ValidateSecret(secret); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("secret inválido: %w", err)
                }</span>

                <span class="cov0" title="0">store, err := storage.NewSecure()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao inicializar storage: %w", err)
                }</span>

                <span class="cov0" title="0">account := types.Account{
                        Name:   accountName,
                        Secret: secret,
                }

                if err := store.SaveAccount(account); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao salvar conta: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Conta '%s' adicionada com sucesso.\n", accountName)
                return nil</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(addCmd)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"

        "mf/internal/storage"
        "mf/internal/totp"
)

var getCmd = &amp;cobra.Command{
        Use:   "get [ACCOUNT_NAME]",
        Short: "Gera um token TOTP para a conta especificada",
        Long:  `Gera um token TOTP (Time-based One-Time Password) para a conta especificada.`,
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                accountName := args[0]

                store, err := storage.NewSecure()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao inicializar storage: %w", err)
                }</span>

                <span class="cov0" title="0">account, err := store.LoadAccount(accountName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao carregar conta: %w", err)
                }</span>

                <span class="cov0" title="0">token, err := totp.GenerateToken(account.Secret)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao gerar token: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Println(token)
                return nil</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(getCmd)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"

        "mf/internal/storage"
)

var listCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "Lista todas as contas disponíveis",
        Long:  `Lista todas as contas disponíveis para geração de tokens TOTP.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                store, err := storage.NewSecure()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao inicializar storage: %w", err)
                }</span>

                <span class="cov0" title="0">accounts, err := store.ListAccounts()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao listar contas: %w", err)
                }</span>

                <span class="cov0" title="0">if len(accounts) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("Nenhuma conta encontrada.")
                        return nil
                }</span>

                <span class="cov0" title="0">fmt.Println("Contas disponíveis:")
                for _, account := range accounts </span><span class="cov0" title="0">{
                        fmt.Printf("  %s\n", account)
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(listCmd)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

var (
        appVersion   = "dev"
        appBuildTime = "unknown"
)

var rootCmd = &amp;cobra.Command{
        Use:   "mf",
        Short: "MF - Multi-Factor Authentication Token Generator",
        Long: `MF is a secure, cross-platform command-line application for generating 
TOTP (Time-based One-Time Password) tokens for multi-factor authentication.

Features:
• Secure storage using system keychain with encrypted fallback
• Cross-platform support (Linux, Windows, macOS)
• Script-friendly with no password prompts
• Automatic migration from plain text to encrypted storage`,
        Version: appVersion,
}

func Execute() error <span class="cov0" title="0">{
        return rootCmd.Execute()
}</span>

func SetVersion(version, buildTime string) <span class="cov0" title="0">{
        appVersion = version
        appBuildTime = buildTime
        rootCmd.Version = version
        rootCmd.SetVersionTemplate(fmt.Sprintf("MF version %s (built %s)\n", version, buildTime))
}</span>

func init() <span class="cov0" title="0">{
        cobra.OnInitialize()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package secure

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"

        "golang.org/x/crypto/pbkdf2"
        "mf/internal/types"
)

type EncryptedStorage struct {
        configDir string
        key       []byte
}

type EncryptedProvider struct{}

func (p *EncryptedProvider) IsAvailable() bool <span class="cov8" title="1">{
        return true
}</span>

func (p *EncryptedProvider) GetStorage() (SecureStorage, error) <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user home directory: %w", err)
        }</span>

        <span class="cov8" title="1">configDir := filepath.Join(homeDir, ".config", "mf")
        if err := os.MkdirAll(configDir, 0700); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        <span class="cov8" title="1">machineKey, err := GetMachineKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get machine key: %w", err)
        }</span>

        <span class="cov8" title="1">key := pbkdf2.Key(machineKey, []byte("mf-salt"), 10000, 32, sha256.New)

        return &amp;EncryptedStorage{
                configDir: configDir,
                key:       key,
        }, nil</span>
}

func (e *EncryptedStorage) Store(account types.Account) error <span class="cov8" title="1">{
        data, err := json.Marshal(account)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal account: %w", err)
        }</span>

        <span class="cov8" title="1">encryptedData, err := e.encrypt(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encrypt account data: %w", err)
        }</span>

        <span class="cov8" title="1">filename := filepath.Join(e.configDir, account.Name+".enc")
        if err := os.WriteFile(filename, encryptedData, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write encrypted account file: %w", err)
        }</span>

        <span class="cov8" title="1">e.removeOldFormat(account.Name)
        return nil</span>
}

func (e *EncryptedStorage) Retrieve(name string) (*types.Account, error) <span class="cov8" title="1">{
        filename := filepath.Join(e.configDir, name+".enc")
        encryptedData, err := os.ReadFile(filename)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        if account, legacyErr := e.tryLoadLegacy(name); legacyErr == nil </span><span class="cov0" title="0">{
                                e.Store(*account)
                                return account, nil
                        }</span>
                        <span class="cov8" title="1">return nil, fmt.Errorf("account '%s' not found", name)</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read encrypted account file: %w", err)</span>
        }

        <span class="cov8" title="1">data, err := e.decrypt(encryptedData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt account data: %w", err)
        }</span>

        <span class="cov8" title="1">var account types.Account
        if err := json.Unmarshal(data, &amp;account); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal account data: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;account, nil</span>
}

func (e *EncryptedStorage) List() ([]string, error) <span class="cov8" title="1">{
        entries, err := os.ReadDir(e.configDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config directory: %w", err)
        }</span>

        <span class="cov8" title="1">var accounts []string
        for _, entry := range entries </span><span class="cov8" title="1">{
                if !entry.IsDir() </span><span class="cov8" title="1">{
                        name := entry.Name()
                        if filepath.Ext(name) == ".enc" </span><span class="cov8" title="1">{
                                accountName := name[:len(name)-4]
                                accounts = append(accounts, accountName)
                        }</span> else<span class="cov0" title="0"> if filepath.Ext(name) == ".json" </span><span class="cov0" title="0">{
                                accountName := name[:len(name)-5]
                                accounts = append(accounts, accountName)
                        }</span>
                }
        }

        <span class="cov8" title="1">return accounts, nil</span>
}

func (e *EncryptedStorage) Delete(name string) error <span class="cov8" title="1">{
        filename := filepath.Join(e.configDir, name+".enc")
        if err := os.Remove(filename); err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("account '%s' not found", name)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to delete encrypted account file: %w", err)</span>
        }

        <span class="cov8" title="1">e.removeOldFormat(name)
        return nil</span>
}

func (e *EncryptedStorage) encrypt(data []byte) ([]byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(e.key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ciphertext := gcm.Seal(nonce, nonce, data, nil)
        return ciphertext, nil</span>
}

func (e *EncryptedStorage) decrypt(data []byte) ([]byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(e.key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(data) &lt; gcm.NonceSize() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ciphertext too short")
        }</span>

        <span class="cov8" title="1">nonce, ciphertext := data[:gcm.NonceSize()], data[gcm.NonceSize():]
        plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return plaintext, nil</span>
}

func (e *EncryptedStorage) tryLoadLegacy(name string) (*types.Account, error) <span class="cov8" title="1">{
        filename := filepath.Join(e.configDir, name+".json")
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var account types.Account
        if err := json.Unmarshal(data, &amp;account); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;account, nil</span>
}

func (e *EncryptedStorage) removeOldFormat(name string) <span class="cov8" title="1">{
        oldFile := filepath.Join(e.configDir, name+".json")
        os.Remove(oldFile)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package secure

import (
        "encoding/json"
        "fmt"

        "github.com/zalando/go-keyring"
        "mf/internal/types"
)

const serviceName = "mf-totp"

type KeychainStorage struct{}

type KeychainProvider struct{}

func (p *KeychainProvider) IsAvailable() bool <span class="cov0" title="0">{
        err := keyring.Set(serviceName+"-test", "test", "test")
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">keyring.Delete(serviceName+"-test", "test")
        return true</span>
}

func (p *KeychainProvider) GetStorage() (SecureStorage, error) <span class="cov0" title="0">{
        return &amp;KeychainStorage{}, nil
}</span>

func (k *KeychainStorage) Store(account types.Account) error <span class="cov0" title="0">{
        data, err := json.Marshal(account)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal account: %w", err)
        }</span>

        <span class="cov0" title="0">err = keyring.Set(serviceName, account.Name, string(data))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store in keychain: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (k *KeychainStorage) Retrieve(name string) (*types.Account, error) <span class="cov0" title="0">{
        data, err := keyring.Get(serviceName, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("account '%s' not found in keychain: %w", name, err)
        }</span>

        <span class="cov0" title="0">var account types.Account
        if err := json.Unmarshal([]byte(data), &amp;account); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal account data: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;account, nil</span>
}

func (k *KeychainStorage) List() ([]string, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("keychain does not support listing all entries")
}</span>

func (k *KeychainStorage) Delete(name string) error <span class="cov0" title="0">{
        err := keyring.Delete(serviceName, name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete account '%s' from keychain: %w", name, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package secure

import (
        "crypto/md5"
        "fmt"
        "os"
        "os/user"
        "runtime"
        "strings"
)

func GetMachineKey() ([]byte, error) <span class="cov8" title="1">{
        var identifiers []string

        hostname, err := os.Hostname()
        if err == nil </span><span class="cov8" title="1">{
                identifiers = append(identifiers, hostname)
        }</span>

        <span class="cov8" title="1">currentUser, err := user.Current()
        if err == nil </span><span class="cov8" title="1">{
                identifiers = append(identifiers, currentUser.Uid, currentUser.Username)
        }</span>

        <span class="cov8" title="1">identifiers = append(identifiers, runtime.GOOS, runtime.GOARCH)

        if len(identifiers) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to gather machine identifiers")
        }</span>

        <span class="cov8" title="1">combined := strings.Join(identifiers, "|")
        hash := md5.Sum([]byte(combined))
        return hash[:], nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package secure

import (
        "fmt"
        "mf/internal/types"
)

type Manager struct {
        primary   SecureStorage
        secondary SecureStorage
}

func NewManager() (*Manager, error) <span class="cov0" title="0">{
        var primary, secondary SecureStorage

        keychainProvider := &amp;KeychainProvider{}
        if keychainProvider.IsAvailable() </span><span class="cov0" title="0">{
                var err error
                primary, err = keychainProvider.GetStorage()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to initialize keychain storage: %w", err)
                }</span>
        }

        <span class="cov0" title="0">encryptedProvider := &amp;EncryptedProvider{}
        var err error
        secondary, err = encryptedProvider.GetStorage()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize encrypted storage: %w", err)
        }</span>

        <span class="cov0" title="0">if primary == nil </span><span class="cov0" title="0">{
                primary = secondary
                secondary = nil
        }</span>

        <span class="cov0" title="0">return &amp;Manager{
                primary:   primary,
                secondary: secondary,
        }, nil</span>
}

func (m *Manager) Store(account types.Account) error <span class="cov0" title="0">{
        err := m.primary.Store(account)
        if err != nil &amp;&amp; m.secondary != nil </span><span class="cov0" title="0">{
                return m.secondary.Store(account)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (m *Manager) Retrieve(name string) (*types.Account, error) <span class="cov0" title="0">{
        account, err := m.primary.Retrieve(name)
        if err != nil &amp;&amp; m.secondary != nil </span><span class="cov0" title="0">{
                return m.secondary.Retrieve(name)
        }</span>
        <span class="cov0" title="0">return account, err</span>
}

func (m *Manager) List() ([]string, error) <span class="cov0" title="0">{
        accounts, err := m.primary.List()
        if err != nil &amp;&amp; m.secondary != nil </span><span class="cov0" title="0">{
                return m.secondary.List()
        }</span>
        <span class="cov0" title="0">return accounts, err</span>
}

func (m *Manager) Delete(name string) error <span class="cov0" title="0">{
        err := m.primary.Delete(name)
        if err != nil &amp;&amp; m.secondary != nil </span><span class="cov0" title="0">{
                return m.secondary.Delete(name)
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package storage

import (
        "fmt"
        "mf/internal/secure"
        "mf/internal/types"
)

type SecureStorage struct {
        manager *secure.Manager
}

func NewSecure() (*SecureStorage, error) <span class="cov8" title="1">{
        manager, err := secure.NewManager()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize secure storage: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;SecureStorage{manager: manager}, nil</span>
}

func (s *SecureStorage) SaveAccount(account types.Account) error <span class="cov8" title="1">{
        return s.manager.Store(account)
}</span>

func (s *SecureStorage) LoadAccount(name string) (*types.Account, error) <span class="cov8" title="1">{
        return s.manager.Retrieve(name)
}</span>

func (s *SecureStorage) ListAccounts() ([]string, error) <span class="cov8" title="1">{
        return s.manager.List()
}</span>

func (s *SecureStorage) DeleteAccount(name string) error <span class="cov8" title="1">{
        return s.manager.Delete(name)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package storage

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "mf/internal/types"
)

type Storage struct {
        configDir string
}

func New() (*Storage, error) <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user home directory: %w", err)
        }</span>

        <span class="cov8" title="1">configDir := filepath.Join(homeDir, ".config", "mf")
        if err := os.MkdirAll(configDir, 0700); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Storage{configDir: configDir}, nil</span>
}

func (s *Storage) SaveAccount(account types.Account) error <span class="cov8" title="1">{
        filename := filepath.Join(s.configDir, account.Name+".json")
        data, err := json.MarshalIndent(account, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal account data: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(filename, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write account file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *Storage) LoadAccount(name string) (*types.Account, error) <span class="cov8" title="1">{
        filename := filepath.Join(s.configDir, name+".json")
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("account '%s' not found", name)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read account file: %w", err)</span>
        }

        <span class="cov8" title="1">var account types.Account
        if err := json.Unmarshal(data, &amp;account); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal account data: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;account, nil</span>
}

func (s *Storage) ListAccounts() ([]string, error) <span class="cov8" title="1">{
        entries, err := os.ReadDir(s.configDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config directory: %w", err)
        }</span>

        <span class="cov8" title="1">var accounts []string
        for _, entry := range entries </span><span class="cov8" title="1">{
                if !entry.IsDir() &amp;&amp; filepath.Ext(entry.Name()) == ".json" </span><span class="cov8" title="1">{
                        name := entry.Name()[:len(entry.Name())-5]
                        accounts = append(accounts, name)
                }</span>
        }

        <span class="cov8" title="1">return accounts, nil</span>
}

func (s *Storage) DeleteAccount(name string) error <span class="cov8" title="1">{
        filename := filepath.Join(s.configDir, name+".json")
        if err := os.Remove(filename); err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return fmt.Errorf("account '%s' not found", name)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to delete account file: %w", err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package totp

import (
        "fmt"
        "time"

        "github.com/pquerna/otp/totp"
)

func GenerateToken(secret string) (string, error) <span class="cov8" title="1">{
        token, err := totp.GenerateCode(secret, time.Now())
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to generate TOTP token: %w", err)
        }</span>
        <span class="cov8" title="1">return token, nil</span>
}

func ValidateSecret(secret string) error <span class="cov8" title="1">{
        _, err := totp.GenerateCode(secret, time.Now())
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid secret: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "fmt"
        "os"

        "mf/cmd"
)

var (
        version   = "dev"
        buildTime = "unknown"
)

func main() <span class="cov0" title="0">{
        cmd.SetVersion(version, buildTime)
        if err := cmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
